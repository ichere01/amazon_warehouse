#include "Packager.h"
using namespace std;
#include <cstdlib>
#include <iostream>

Packager::Packager()
{
    head = NULL;
    tail = NULL;
    time = 0; // current time
    isWorking = true;
}


void Packager::addNormal(Order toAdd)
{
    Order* newOrder = new Order;

    *newOrder = toAdd;

    if (isEmpty()){
	head = newOrder;
	tail = head;
    }

    tail -> next = newOrder;
    tail = newOrder;
    
    newOrder -> next = NULL;

    normalWait += toAdd.packTime;
}

void Packager::addSupreme(Order toAdd)
{
    Order* newOrder = new Order;

    *newOrder = toAdd;

    if (head == NULL || !head -> isSupreme){ // no supremes in queue
	newOrder -> next = head;
	head  = newOrder;
    }

    else {

	Order* curr  = head; //to find where in the queue toAdd should go
	Order* prev = NULL;
	while(curr != NULL && curr -> isSupreme){ //find last supreme in queue
	    prev  = curr;
	    curr = curr -> next;
	}
 
	newOrder -> next = curr;
	prev -> next = newOrder;
    }
    supremeWait += toAdd.packTime;
}

bool Packager::isEmpty()
{
    return head == NULL;
}

void Packager::print()
{
    Order* iter = head;

    //while (iter != NULL){
	cout << "Order " << iter -> ID << " for ";

	   if (iter -> isSupreme)
		cout << "supreme customer ";
	    else
		cout << "regular customer ";
	    
	    cout  << "arrived at time " << iter -> arrivalTime
		  << endl << "fetch time " << iter -> fetchTime
		  << " minutes, pack time " << iter -> packTime
		  << endl
		  << "the order was added to packaging queue at time "
		  << iter -> arrivalPackaging << endl << endl;
	    

//	iter = iter -> next;}
	      
}

bool Packager::isPacked()
{
    if( !isEmpty()){

	isWorking = true;
	time++;
	
	(head -> timePacked)--; // Marks passage of a unit of time at retrieval

	if (head -> timePacked <= 0){ // if article has been fetched
	    head -> totalWait = time - head -> arrivalTime; 
	    print(); // outputs data of Order to be sent
	    remove();
	    return true;
	    }
	else
	    return false;
    }
    else{
	isWorking = false; // list is empty, packers job is done
	return false;
    }
}

Order Packager::remove()
{
    if (isEmpty()){
	cerr << "Can't remove from empty list" << endl;
	exit(1);
    }
    Order toRemove = *head; // Create an Order to be returned
    Order* destroyer = head;
    head = head-> next;
    delete destroyer;
    return toRemove;
}
